// qbrush.sip generated by MetaSIP on Thu Dec 25 10:18:49 2014
//
// This file is part of the QtGui Python extension module.
//
// Copyright (c) 2014 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt5.
// 
// This file may be used under the terms of the GNU General Public License
// version 3.0 as published by the Free Software Foundation and appearing in
// the file LICENSE included in the packaging of this file.  Please review the
// following information to ensure the GNU General Public License version 3.0
// requirements will be met: http://www.gnu.org/copyleft/gpl.html.
// 
// If you do not wish to use this file under the terms of the GPL version 3.0
// then you may purchase a commercial license.  For more information contact
// info@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


%ModuleCode
#include <qbrush.h>
%End

class QBrush
{
%TypeHeaderCode
#include <qbrush.h>
%End

%ConvertToTypeCode
// SIP doesn't support automatic type convertors so we explicitly allow a
// QColor or a QGradient to be used whenever a QBrush is expected.  Note that
// SIP must process QColor before QBrush so that the former's QVariant cast
// operator is applied before the latter's.

if (sipIsErr == NULL)
    return (sipCanConvertToType(sipPy, sipType_QBrush, SIP_NO_CONVERTORS) ||
            sipCanConvertToType(sipPy, sipType_QColor, 0) ||
            sipCanConvertToType(sipPy, sipType_QGradient, 0));

if (sipCanConvertToType(sipPy, sipType_QBrush, SIP_NO_CONVERTORS))
{
    *sipCppPtr = reinterpret_cast<QBrush *>(sipConvertToType(sipPy, sipType_QBrush, sipTransferObj, SIP_NO_CONVERTORS, 0, sipIsErr));

    return 0;
}

int state;

if (sipCanConvertToType(sipPy, sipType_QColor, 0))
{
    QColor *c = reinterpret_cast<QColor *>(sipConvertToType(sipPy, sipType_QColor, 0, 0, &state, sipIsErr));

    if (*sipIsErr)
    {
        sipReleaseType(c, sipType_QColor, state);
        return 0;
    }

    *sipCppPtr = new QBrush(*c);

    sipReleaseType(c, sipType_QColor, state);

    return sipGetState(sipTransferObj);
}

QGradient *g = reinterpret_cast<QGradient *>(sipConvertToType(sipPy, sipType_QGradient, 0, 0, &state, sipIsErr));

if (*sipIsErr)
{
    sipReleaseType(g, sipType_QGradient, state);
    return 0;
}

*sipCppPtr = new QBrush(*g);

sipReleaseType(g, sipType_QGradient, state);

return sipGetState(sipTransferObj);
%End

public:
    QBrush();
    QBrush(Qt::BrushStyle bs);
    QBrush(const QColor &color, Qt::BrushStyle style = Qt::SolidPattern);
    QBrush(Qt::GlobalColor color, Qt::BrushStyle style = Qt::SolidPattern);
    QBrush(const QColor &color, const QPixmap &pixmap);
    QBrush(Qt::GlobalColor color, const QPixmap &pixmap);
    QBrush(const QPixmap &pixmap);
    QBrush(const QImage &image);
    QBrush(const QGradient &gradient);
    QBrush(const QBrush &brush);
    QBrush(const QVariant &variant) /NoDerived/;
%MethodCode
        sipCpp = new QBrush(a0->value<QBrush>());
%End

    ~QBrush();
    void setStyle(Qt::BrushStyle);
    QPixmap texture() const;
    void setTexture(const QPixmap &pixmap);
    void setColor(const QColor &color);
    const QGradient *gradient() const;
    bool isOpaque() const;
    bool operator==(const QBrush &b) const;
    bool operator!=(const QBrush &b) const;
    void setColor(Qt::GlobalColor acolor);
    Qt::BrushStyle style() const;
    const QColor &color() const;
    void setTextureImage(const QImage &image);
    QImage textureImage() const;
    void setTransform(const QTransform &);
    QTransform transform() const;
    void swap(QBrush &other);
};

QDataStream &operator>>(QDataStream &, QBrush & /Constrained/) /ReleaseGIL/;
QDataStream &operator<<(QDataStream &, const QBrush & /Constrained/) /ReleaseGIL/;
typedef QVector<QPair<qreal, QColor>> QGradientStops;

class QGradient
{
%TypeHeaderCode
#include <qbrush.h>
%End

public:
    enum CoordinateMode
    {
        LogicalMode,
        StretchToDeviceMode,
        ObjectBoundingMode,
    };

    enum Type
    {
        LinearGradient,
        RadialGradient,
        ConicalGradient,
        NoGradient,
    };

    enum Spread
    {
        PadSpread,
        ReflectSpread,
        RepeatSpread,
    };

    QGradient();
    QGradient::Type type() const;
    QGradient::Spread spread() const;
    void setColorAt(qreal pos, const QColor &color);
    void setStops(const QGradientStops &stops);
    QGradientStops stops() const;
    bool operator==(const QGradient &gradient) const;
    bool operator!=(const QGradient &other) const;
    void setSpread(QGradient::Spread aspread);
    QGradient::CoordinateMode coordinateMode() const;
    void setCoordinateMode(QGradient::CoordinateMode mode);
};

class QLinearGradient : QGradient
{
%TypeHeaderCode
#include <qbrush.h>
%End

public:
    QLinearGradient();
    QLinearGradient(const QPointF &start, const QPointF &finalStop);
    QLinearGradient(qreal xStart, qreal yStart, qreal xFinalStop, qreal yFinalStop);
    QPointF start() const;
    QPointF finalStop() const;
    void setStart(const QPointF &start);
    void setStart(qreal x, qreal y);
    void setFinalStop(const QPointF &stop);
    void setFinalStop(qreal x, qreal y);
};

class QRadialGradient : QGradient
{
%TypeHeaderCode
#include <qbrush.h>
%End

public:
    QRadialGradient();
    QRadialGradient(const QPointF &center, qreal radius, const QPointF &focalPoint);
    QRadialGradient(const QPointF &center, qreal centerRadius, const QPointF &focalPoint, qreal focalRadius);
    QRadialGradient(const QPointF &center, qreal radius);
    QRadialGradient(qreal cx, qreal cy, qreal radius, qreal fx, qreal fy);
    QRadialGradient(qreal cx, qreal cy, qreal centerRadius, qreal fx, qreal fy, qreal focalRadius);
    QRadialGradient(qreal cx, qreal cy, qreal radius);
    QPointF center() const;
    QPointF focalPoint() const;
    qreal radius() const;
    void setCenter(const QPointF &center);
    void setCenter(qreal x, qreal y);
    void setFocalPoint(const QPointF &focalPoint);
    void setFocalPoint(qreal x, qreal y);
    void setRadius(qreal radius);
    qreal centerRadius() const;
    void setCenterRadius(qreal radius);
    qreal focalRadius() const;
    void setFocalRadius(qreal radius);
};

class QConicalGradient : QGradient
{
%TypeHeaderCode
#include <qbrush.h>
%End

public:
    QConicalGradient();
    QConicalGradient(const QPointF &center, qreal startAngle);
    QConicalGradient(qreal cx, qreal cy, qreal startAngle);
    QPointF center() const;
    qreal angle() const;
    void setCenter(const QPointF &center);
    void setCenter(qreal x, qreal y);
    void setAngle(qreal angle);
};
