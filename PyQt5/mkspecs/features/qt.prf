CONFIG *= thread

#handle defines
win32 {
   contains(QT_CONFIG, shared) {
      # this variable is read by qmake in qmake/generators/win32/msvc_vcproj.cpp
      # function VcprojGenerator::initDeploymentTool(), which contains some hardcoded
      # library names (the ones that were static in Qt 4)
      # it probably doesn't work anymore and should not be in this file
      QMAKE_QT_DLL = 1
   }
}
CONFIG(release, debug|release):DEFINES += QT_NO_DEBUG
contains(QT_CONFIG, force_asserts):DEFINES += QT_FORCE_ASSERTS
no_keywords:DEFINES += QT_NO_KEYWORDS
plugin { #Qt plugins
   static:DEFINES += QT_STATICPLUGIN
   DEFINES += QT_PLUGIN

   # Triggers both on Qt being configured with -arch boundschecker,
   # and if you qmake CONFIG+=boundchecker on your plugin project
   boundschecker|contains(QT_CONFIG,boundschecker) {
      # This option is added for plugins when Qt is configured for Boundschecker,
      # since we want Boundschecker to not instrument the qt_plugin_query_verification_data
      # function, as we call that function without the plugin's dependent DLLs, thus
      # Boundscheckers instrumentation will fail. The function only returns a const char *,
      # so no instrumentation is really needed on that function anyways.
      QMAKE_CFLAGS += /nmignore:*:qt_plugin_query_verification_data
      QMAKE_CXXFLAGS += /nmignore:*:qt_plugin_query_verification_data
   }
}

qtestlib {
    warning("CONFIG+=qtestlib is deprecated. Use QT+=testlib instead.")
    QT += testlib
}
qdbus {
    warning("CONFIG+=qdbus is deprecated. Use QT+=dbus instead.")
    QT += dbus
}
help {
    warning("CONFIG+=help is deprecated. Use QT+=help instead.")
    QT += help-private   # sic!
}
designer {
    warning("CONFIG+=designer is deprecated. Use QT+=designer instead.")
    QT += designer
}
uitools {
    warning("CONFIG+=uitools is deprecated. Use QT+=uitools instead.")
    QT += uitools
}
qaxcontainer {
    warning("CONFIG+=qaxcontainer is deprecated. Use QT+=axcontainer instead.")
    QT += axcontainer
}
qaxserver {
    warning("CONFIG+=qaxserver is deprecated. Use QT+=axserver instead.")
    QT += axserver
}

unset(using_privates)
qtAddModules(QT, LIBS)
qtAddModules(QT_PRIVATE, LIBS_PRIVATE)
!isEmpty(using_privates):!no_private_qt_headers_warning:if(!debug_and_release|!build_pass) {
    message("This project is using private headers and will therefore be tied to this specific Qt module build version.")
    message("Running this project against other versions of the Qt modules may crash at any arbitrary point.")
    message("This is not a bug, but a result of using Qt internals. You have been warned!")
}
qtAddRpathLink($$QT $$QT_PRIVATE)

wince*:static:gui {
   QTLIB += qmenu_wce.res
}

qt_module_deps = $$QT $$QT_PRIVATE
qt_module_deps = $$replace(qt_module_deps, -private$, _private)
qt_module_deps = $$resolve_depends(qt_module_deps, "QT.")

# static builds: link qml import plugins into the app.
contains(qt_module_deps, qml): \
        contains(QT_CONFIG, static):contains(TEMPLATE, .*app):!host_build:!no_import_scan {
    !isEmpty(QTREPOS) {
        for (qrep, QTREPOS): \
            exists($$qrep/qml): \
                QMLPATHS += $$qrep/qml
    } else {
        QMLPATHS += $$[QT_INSTALL_QML/get]
    }

    # run qmlimportscanner
    qtPrepareTool(QMLIMPORTSCANNER, qmlimportscanner, , system)
    for (QMLPATH, QMLPATHS): \
        IMPORTPATHS += -importPath $$QMLPATH

    #message(run $$QMLIMPORTSCANNER $$_PRO_FILE_PWD_  $$IMPORTPATHS)
    JSON = $$system($$QMLIMPORTSCANNER $$_PRO_FILE_PWD_ $$IMPORTPATHS)

    parseJson(JSON, IMPORTS)| error("Failed to parse qmlimportscanner output.")

    !isEmpty(IMPORTS._KEYS_) {
        # add import plugins to LIBS line
        for (key, IMPORTS._KEYS_): {
            PATH = $$eval(IMPORTS.$${key}.path)
            PLUGIN = $$eval(IMPORTS.$${key}.plugin)
            !isEmpty(PATH):!isEmpty(PLUGIN): LIBS *= -L$$PATH -l$${PLUGIN}$$qtPlatformTargetSuffix()
        }

        # create qml_plugin_import.cpp
        IMPORT_FILE_CONT = \
            "// This file is autogenerated by qmake. It imports static plugin classes for" \
            "// static plugins used by QML imports." \
            "$${LITERAL_HASH}include <QtPlugin>"
        for (key, IMPORTS._KEYS_) {
            PLUGIN = $$eval(IMPORTS.$${key}.plugin)
            CLASSNAME = $$eval(IMPORTS.$${key}.classname)
            !isEmpty(PLUGIN) {
                !isEmpty(CLASSNAME) {
                    !contains(ADDED_IMPORTS, $$PLUGIN)  {
                        ADDED_IMPORTS += $$PLUGIN
                        IMPORT_FILE_CONT += "Q_IMPORT_PLUGIN($$CLASSNAME)"
                    }
                } else {
                    error("Plugin $$PLUGIN is missing a classname entry, please add one to the qmldir file.")
                }
            }
        }
        QML_IMPORT_CPP = $$OUT_PWD/$$lower($$basename(TARGET))_qml_plugin_import.cpp
        write_file($$QML_IMPORT_CPP, IMPORT_FILE_CONT)|error("Aborting.")
        SOURCES += $$QML_IMPORT_CPP
        QMAKE_DISTCLEAN += $$QML_IMPORT_CPP

        # copy qml files. this part is platform spesific.
        mac {
            osx {
                # Note: user can override QMAKE_BUNDLE_QML from pro file to change target bundle path
                isEmpty(QMAKE_QML_BUNDLE_PATH):QMAKE_QML_BUNDLE_PATH = "Resources/qt_qml"
                qmlTargetPath = $$OUT_PWD/$${TARGET}.app/Contents/$$QMAKE_QML_BUNDLE_PATH
                qtconfTargetPath = $$OUT_PWD/$${TARGET}.app/Contents/Resources/qt.conf
            } else {
                # iOS: flat bundle layout (no Contents/Resources)
                isEmpty(QMAKE_QML_BUNDLE_PATH):QMAKE_QML_BUNDLE_PATH = "qt_qml"
                qmlTargetPath = $CODESIGNING_FOLDER_PATH/$$QMAKE_QML_BUNDLE_PATH
                qtconfTargetPath = $CODESIGNING_FOLDER_PATH/qt.conf
            }

            # set import path in qt.conf to point to the bundeled qml:
            QT_CONF_CONTENTS = \
                "[Paths]" \
                "Imports = $$QMAKE_QML_BUNDLE_PATH" \
                "Qml2Imports = $$QMAKE_QML_BUNDLE_PATH"
            write_file("$$OUT_PWD/qt.conf", QT_CONF_CONTENTS)|error("Aborting.")

            # write qt.conf and copy each qml import dir into the bundle.
            # But strip away archives and other files that are not needed:
            !isEmpty(QMAKE_POST_LINK): QMAKE_POST_LINK += ";"
            QMAKE_POST_LINK += \
                "cp $$OUT_PWD/qt.conf $$qtconfTargetPath; " \
                "test -d $$qmlTargetPath && rm -r $$qmlTargetPath; " \
                "mkdir -p $$qmlTargetPath && " \
                "for p in $$QMLPATHS; do" \
                    "rsync -r --exclude='*.a' --exclude='*.prl' --exclude='*.qmltypes' "
            macx-xcode: QMAKE_POST_LINK += "$p/ $$qmlTargetPath; done"
            else: QMAKE_POST_LINK += "\$\$p/ $$qmlTargetPath; done"
        }
    }
}

!import_qpa_plugin {
    warning("CONFIG-=import_qpa_plugin is deprecated. Use QTPLUGIN.platforms=- instead.")
    QTPLUGIN.platforms = -
} else: qpa_minimal_plugin {
    warning("CONFIG+=qpa_minimal_plugin is deprecated. Use QTPLUGIN.platforms=qminimal instead.")
    QTPLUGIN.platforms = qminimal
}

contains(TEMPLATE, .*app) {
    autoplugs =
    for (qtmod, qt_module_deps) {
        for (ptype, QT.$${qtmod}.plugin_types) {
            isEmpty(QTPLUGIN.$$ptype) {
                for (plug, QT_PLUGINS) {
                    equals(QT_PLUGIN.$${plug}.TYPE, $$ptype) {
                        for (dep, QT_PLUGIN.$${plug}.EXTENDS) {
                            !contains(qt_module_deps, $$dep) {
                                plug =
                                break()
                            }
                        }
                        autoplugs += $$plug
                    }
                }
            } else {
                plug = $$eval(QTPLUGIN.$$ptype)
                !equals(plug, -): \
                    autoplugs += $$plug
            }
        }
    }
    manualplugs = $$QTPLUGIN
    manualplugs -= $$autoplugs
    QTPLUGIN -= $$manualplugs
    !isEmpty(QTPLUGIN): \
        warning("Redundant entries in QTPLUGIN: $$QTPLUGIN")
    QTPLUGIN = $$manualplugs $$autoplugs
}

QT_PLUGIN_VERIFY = DEPLOYMENT_PLUGIN
contains(QT_CONFIG, static) {
    QT_PLUGIN_VERIFY += QTPLUGIN
    force_import_plugins|contains(TEMPLATE, .*app) {
        import_plugins:!isEmpty(QTPLUGIN) {
            IMPORT_FILE_CONT = \
                "// This file is autogenerated by qmake. It imports static plugin classes for" \
                "// static plugins specified using QTPLUGIN and QT_PLUGIN_CLASS.<plugin> variables." \
                "$${LITERAL_HASH}include <QtPlugin>"
            for(IMPORT_PLUG, $$list($$unique(QTPLUGIN))) {
                PLUG_CLASS = $$eval(QT_PLUGIN.$${IMPORT_PLUG}.CLASS_NAME)
                !isEmpty(PLUG_CLASS): \
                    IMPORT_FILE_CONT += "Q_IMPORT_PLUGIN($$PLUG_CLASS)"
                else: \
                    warning("Plugin class name could not be determined for $$IMPORT_PLUG plugin.")
            }
            IMPORT_CPP = $$OUT_PWD/$$lower($$basename(TARGET))_plugin_import.cpp
            write_file($$IMPORT_CPP, IMPORT_FILE_CONT)|error("Aborting.")
            SOURCES += $$IMPORT_CPP
            QMAKE_DISTCLEAN += $$IMPORT_CPP
        }
    }
}

for(QT_CURRENT_VERIFY, $$list($$QT_PLUGIN_VERIFY)) {
    for(QTPLUG, $$list($$lower($$unique($$QT_CURRENT_VERIFY)))) {
       # Check if the plugin is known to Qt. We can use this to determine
       # the plugin path. Unknown plugins must rely on the default link path.
       QT_PLUGINPATH = $$eval(QT_PLUGIN.$${QTPLUG}.TYPE)

        # Generate the plugin linker line
        target_qt:isEqual(TARGET, QTPLUG) {
            warning($$TARGET cannot have a QTPLUGIN of $$QTPLUG)
        } else {
            QT_LINKAGE = -l$${QTPLUG}$$qtPlatformTargetSuffix()
        }

        # Only link against plugin in static builds
        isEqual(QT_CURRENT_VERIFY, QTPLUGIN): {
            !isEmpty(QT_PLUGINPATH) {
                plugpath = $$eval(QT_PLUGIN.$${QTPLUG}.PATH)
                isEmpty(plugpath): \
                    plugpath = $$[QT_INSTALL_PLUGINS/get]
                LIBS *= -L$$plugpath/$$QT_PLUGINPATH
            }
                LIBS += $$QT_LINKAGE
            # if the plugin is linked statically there is no need to deploy it
            DEPLOYMENT_PLUGIN -= $$QT_CURRENT_VERIFY
        }
        isEqual(QT_CURRENT_VERIFY, DEPLOYMENT_PLUGIN):shared:if(wince*|winrt): {
            QT_ITEM =
            debug: QT_ITEM = $${QTPLUG}d4.dll
            else: QT_ITEM = $${QTPLUG}4.dll

            eval(qt_additional_plugin_$${QTPLUG}.files = $$[QT_INSTALL_PLUGINS/get]/$${QT_PLUGINPATH}/$${QT_ITEM})
            eval(qt_additional_plugin_$${QTPLUG}.path = $${QT_PLUGINPATH})

            DEPLOYMENT *= qt_additional_plugin_$${QTPLUG}
        }
    }
}
