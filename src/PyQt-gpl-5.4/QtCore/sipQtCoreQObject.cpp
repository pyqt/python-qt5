/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.16.5 on Thu Feb 05 16:17:22 2015
 *
 * Copyright (c) 2014 Riverbank Computing Limited <info@riverbankcomputing.com>
 * 
 * This file is part of PyQt5.
 * 
 * This file may be used under the terms of the GNU General Public License
 * version 3.0 as published by the Free Software Foundation and appearing in
 * the file LICENSE included in the packaging of this file.  Please review the
 * following information to ensure the GNU General Public License version 3.0
 * requirements will be met: http://www.gnu.org/copyleft/gpl.html.
 * 
 * If you do not wish to use this file under the terms of the GPL version 3.0
 * then you may purchase a commercial license.  For more information contact
 * info@riverbankcomputing.com.
 * 
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include "sipAPIQtCore.h"

#line 28 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
#include <qobject.h>
#line 29 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"

#line 26 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 33 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
#line 30 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 36 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
#line 26 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 39 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
#line 234 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 42 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
#line 222 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 45 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
#line 27 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qstring.sip"
#include <qstring.h>
#line 48 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
#line 30 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 51 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
#line 36 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 54 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
#line 32 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 57 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
#line 144 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 60 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
#line 30 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 63 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
#line 26 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qthread.sip"
#include <qthread.h>
#line 66 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
#line 30 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 69 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
#line 30 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 72 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
#line 30 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 75 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
#line 32 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
// This is needed by the tr() handwritten implementation.
#include <qcoreapplication.h>


// These are the helper functions for QObject::findChild() and
// QObject::findChildren.

// Wrap the given type in a 1-tuple.
static PyObject *qtcore_type_to_tuple(PyObject *type)
{
    PyObject *tuple = PyTuple_New(1);

    if (tuple)
    {
        Py_INCREF(type);
        PyTuple_SET_ITEM(tuple, 0, type);
    }

    return tuple;
}


// Check all elements of a given tuple are type objects and return a new
// reference to the tuple if so.
static PyObject *qtcore_check_tuple_types(PyObject *types)
{
    for (SIP_SSIZE_T i = 0; i < PyTuple_GET_SIZE(types); ++i)
        if (!PyObject_TypeCheck(PyTuple_GET_ITEM(types, i), &PyType_Type))
        {
            PyErr_SetString(PyExc_TypeError,
                    "all elements of the types argument must be type objects");
            return 0;
        }

    Py_INCREF(types);
    return types;
}


// Do the main work of finding a child.
static PyObject *qtcore_do_find_child(const QObject *parent, PyObject *types, const QString &name, Qt::FindChildOptions options)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return 0;

        // Allow for proxies.
        QObject *resolved = reinterpret_cast<QObject *>(sipGetAddress((sipSimpleWrapper *)pyo));

        if (name.isNull() || resolved->objectName() == name)
            for (SIP_SSIZE_T t = 0; t < PyTuple_GET_SIZE(types); ++t)
                if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GET_ITEM(types, t)))
                    return pyo;

        Py_DECREF(pyo);
    }

    if (options == Qt::FindChildrenRecursively)
        for (i = 0; i < children.size(); ++i)
        {
            PyObject *pyo = qtcore_do_find_child(children.at(i), types, name, options);

            if (pyo != Py_None)
                return pyo;

            Py_DECREF(pyo);
        }

    Py_INCREF(Py_None);
    return Py_None;
}


// Find a child that is one of a number of types and with an optional name.
static PyObject *qtcore_FindChild(const QObject *parent, PyObject *types, const QString &name, Qt::FindChildOptions options)
{
    // Check that the types checking was successful.
    if (!types)
        return 0;

    PyObject *child = qtcore_do_find_child(parent, types, name, options);

    Py_DECREF(types);

    return child;
}


// Do the main work of finding the children with a string name.
static bool qtcore_do_find_children(const QObject *parent, PyObject *types, const QString &name, Qt::FindChildOptions options, PyObject *list)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return false;

        // Allow for proxies.
        QObject *resolved = reinterpret_cast<QObject *>(sipGetAddress((sipSimpleWrapper *)pyo));

        if (name.isNull() || resolved->objectName() == name)
            for (SIP_SSIZE_T t = 0; t < PyTuple_GET_SIZE(types); ++t)
                if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GET_ITEM(types, t)))
                    if (PyList_Append(list, pyo) < 0)
                    {
                        Py_DECREF(pyo);
                        return false;
                    }

        Py_DECREF(pyo);

        if (options == Qt::FindChildrenRecursively)
        {
            bool ok = qtcore_do_find_children(obj, types, name, options, list);

            if (!ok)
                return false;
        }
    }

    return true;
}


// Find a child that is one of a number of types and with an optional string
// name.
static PyObject *qtcore_FindChildren(const QObject *parent, PyObject *types, const QString &name, Qt::FindChildOptions options)
{
    // Check that the types checking was successful.
    if (!types)
        return 0;

    PyObject *list = PyList_New(0);

    if (list)
        if (!qtcore_do_find_children(parent, types, name, options, list))
            Py_DECREF(list);

    Py_DECREF(types);

    return list;
}


// Do the main work of finding the children with a QRegExp name.
static bool qtcore_do_find_children(const QObject *parent, PyObject *types, const QRegExp &re, Qt::FindChildOptions options, PyObject *list)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return false;

        if (re.indexIn(obj->objectName()) >= 0)
            for (SIP_SSIZE_T t = 0; t < PyTuple_GET_SIZE(types); ++t)
                if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GET_ITEM(types, t)))
                    if (PyList_Append(list, pyo) < 0)
                    {
                        Py_DECREF(pyo);
                        return false;
                    }

        Py_DECREF(pyo);

        if (options == Qt::FindChildrenRecursively)
        {
            bool ok = qtcore_do_find_children(obj, types, re, options, list);

            if (!ok)
                return false;
        }
    }

    return true;
}


// Find a child that is one of a number of types and with an optional QRegExp
// name.
static PyObject *qtcore_FindChildren(const QObject *parent, PyObject *types, const QRegExp &re, Qt::FindChildOptions options)
{
    // Check that the types checking was successful.
    if (!types)
        return 0;

    PyObject *list = PyList_New(0);

    if (list)
        if (!qtcore_do_find_children(parent, types, re, options, list))
            Py_DECREF(list);

    Py_DECREF(types);

    return list;
}


// Do the main work of finding the children with a QRegularExpression name.
static bool qtcore_do_find_children(const QObject *parent, PyObject *types, const QRegularExpression &re, Qt::FindChildOptions options, PyObject *list)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return false;

        QRegularExpressionMatch m = re.match(obj->objectName());
        
        if (m.hasMatch())
            for (SIP_SSIZE_T t = 0; t < PyTuple_GET_SIZE(types); ++t)
                if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GET_ITEM(types, t)))
                    if (PyList_Append(list, pyo) < 0)
                    {
                        Py_DECREF(pyo);
                        return false;
                    }

        Py_DECREF(pyo);

        if (options == Qt::FindChildrenRecursively)
        {
            bool ok = qtcore_do_find_children(obj, types, re, options, list);

            if (!ok)
                return false;
        }
    }

    return true;
}


// Find a child that is one of a number of types and with an optional
// QRegularExpression name.
static PyObject *qtcore_FindChildren(const QObject *parent, PyObject *types, const QRegularExpression &re, Qt::FindChildOptions options)
{
    // Check that the types checking was successful.
    if (!types)
        return 0;

    PyObject *list = PyList_New(0);

    if (list)
        if (!qtcore_do_find_children(parent, types, re, options, list))
            Py_DECREF(list);

    Py_DECREF(types);

    return list;
}
#line 349 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"


class sipQObject : public QObject
{
public:
    sipQObject(QObject*);
    virtual ~sipQObject();

    int qt_metacall(QMetaObject::Call,int,void **);
    void *qt_metacast(const char *);
    const QMetaObject *metaObject() const;

    /*
     * There is a public method for every protected method visible from
     * this class.
     */
    QObject* sipProtect_sender() const;
    int sipProtect_receivers(const char*) const;
    void sipProtectVirt_timerEvent(bool,QTimerEvent*);
    void sipProtectVirt_childEvent(bool,QChildEvent*);
    void sipProtectVirt_customEvent(bool,QEvent*);
    void sipProtectVirt_connectNotify(bool,const QMetaMethod&);
    void sipProtectVirt_disconnectNotify(bool,const QMetaMethod&);
    int sipProtect_senderSignalIndex() const;
    bool sipProtect_isSignalConnected(const QMetaMethod&) const;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const QMetaMethod&);
    void connectNotify(const QMetaMethod&);
    void customEvent(QEvent*);
    void childEvent(QChildEvent*);
    void timerEvent(QTimerEvent*);
    bool eventFilter(QObject*,QEvent*);
    bool event(QEvent*);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQObject(const sipQObject &);
    sipQObject &operator = (const sipQObject &);

    char sipPyMethods[7];
};

sipQObject::sipQObject(QObject*a0): QObject(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQObject::~sipQObject()
{
    sipCommonDtor(sipPySelf);
}

const QMetaObject *sipQObject::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtCore_qt_metaobject(sipPySelf,sipType_QObject);
}

int sipQObject::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id = QObject::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtCore_qt_metacall(sipPySelf,sipType_QObject,_c,_id,_a);

    return _id;
}

void *sipQObject::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtCore_qt_metacast(sipPySelf, sipType_QObject, _clname, &sipCpp) ? sipCpp : QObject::qt_metacast(_clname));
}

void sipQObject::disconnectNotify(const QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_disconnectNotify);

    if (!sipMeth)
    {
        QObject::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtCore_46(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const QMetaMethod&);
    extern void sipVEH_QtCore_PyQt5(sipSimpleWrapper *, sip_gilstate_t);

    sipVH_QtCore_46(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, a0);
}

void sipQObject::connectNotify(const QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_connectNotify);

    if (!sipMeth)
    {
        QObject::connectNotify(a0);
        return;
    }

    extern void sipVH_QtCore_46(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const QMetaMethod&);
    extern void sipVEH_QtCore_PyQt5(sipSimpleWrapper *, sip_gilstate_t);

    sipVH_QtCore_46(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, a0);
}

void sipQObject::customEvent(QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,NULL,sipName_customEvent);

    if (!sipMeth)
    {
        QObject::customEvent(a0);
        return;
    }

    extern void sipVH_QtCore_25(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, QEvent*);
    extern void sipVEH_QtCore_PyQt5(sipSimpleWrapper *, sip_gilstate_t);

    sipVH_QtCore_25(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, a0);
}

void sipQObject::childEvent(QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,NULL,sipName_childEvent);

    if (!sipMeth)
    {
        QObject::childEvent(a0);
        return;
    }

    extern void sipVH_QtCore_47(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, QChildEvent*);
    extern void sipVEH_QtCore_PyQt5(sipSimpleWrapper *, sip_gilstate_t);

    sipVH_QtCore_47(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, a0);
}

void sipQObject::timerEvent(QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,NULL,sipName_timerEvent);

    if (!sipMeth)
    {
        QObject::timerEvent(a0);
        return;
    }

    extern void sipVH_QtCore_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, QTimerEvent*);
    extern void sipVEH_QtCore_PyQt5(sipSimpleWrapper *, sip_gilstate_t);

    sipVH_QtCore_9(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, a0);
}

bool sipQObject::eventFilter(QObject*a0,QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,NULL,sipName_eventFilter);

    if (!sipMeth)
        return QObject::eventFilter(a0,a1);

    extern bool sipVH_QtCore_26(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, QObject*,QEvent*);
    extern void sipVEH_QtCore_PyQt5(sipSimpleWrapper *, sip_gilstate_t);

    return sipVH_QtCore_26(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, a0, a1);
}

bool sipQObject::event(QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,NULL,sipName_event);

    if (!sipMeth)
        return QObject::event(a0);

    extern bool sipVH_QtCore_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, QEvent*);
    extern void sipVEH_QtCore_PyQt5(sipSimpleWrapper *, sip_gilstate_t);

    return sipVH_QtCore_5(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, a0);
}

QObject* sipQObject::sipProtect_sender() const
{
    return QObject::sender();
}

int sipQObject::sipProtect_receivers(const char*a0) const
{
    return QObject::receivers(a0);
}

void sipQObject::sipProtectVirt_timerEvent(bool sipSelfWasArg,QTimerEvent*a0)
{
    (sipSelfWasArg ? QObject::timerEvent(a0) : timerEvent(a0));
}

void sipQObject::sipProtectVirt_childEvent(bool sipSelfWasArg,QChildEvent*a0)
{
    (sipSelfWasArg ? QObject::childEvent(a0) : childEvent(a0));
}

void sipQObject::sipProtectVirt_customEvent(bool sipSelfWasArg,QEvent*a0)
{
    (sipSelfWasArg ? QObject::customEvent(a0) : customEvent(a0));
}

void sipQObject::sipProtectVirt_connectNotify(bool sipSelfWasArg,const QMetaMethod& a0)
{
    (sipSelfWasArg ? QObject::connectNotify(a0) : connectNotify(a0));
}

void sipQObject::sipProtectVirt_disconnectNotify(bool sipSelfWasArg,const QMetaMethod& a0)
{
    (sipSelfWasArg ? QObject::disconnectNotify(a0) : disconnectNotify(a0));
}

int sipQObject::sipProtect_senderSignalIndex() const
{
    return QObject::senderSignalIndex();
}

bool sipQObject::sipProtect_isSignalConnected(const QMetaMethod& a0) const
{
    return QObject::isSignalConnected(a0);
}


PyDoc_STRVAR(doc_QObject_metaObject, "QObject.metaObject() -> QMetaObject");

extern "C" {static PyObject *meth_QObject_metaObject(PyObject *, PyObject *);}
static PyObject *meth_QObject_metaObject(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            const QMetaObject*sipRes;

            sipRes = sipCpp->metaObject();

            return sipConvertFromType(const_cast<QMetaObject *>(sipRes),sipType_QMetaObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_metaObject, doc_QObject_metaObject);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_pyqtConfigure, "QObject.pyqtConfigure(...)\n"
    "\n"
    "Each keyword argument is either the name of a Qt property or a Qt signal.\n"
    "For properties the property is set to the given value which should be of an\n"
    "appropriate type.\n"
    "For signals the signal is connected to the given value which should be a\n"
    "callable.");

extern "C" {static PyObject *meth_QObject_pyqtConfigure(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_pyqtConfigure(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
#line 430 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
        return qpycore_pyqtconfigure(sipSelf, sipArgs, sipKwds);
#line 644 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
}


PyDoc_STRVAR(doc_QObject___getattr__, "QObject.__getattr__(str) -> object");

extern "C" {static PyObject *meth_QObject___getattr__(PyObject *, PyObject *);}
static PyObject *meth_QObject___getattr__(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const char* a0;
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bs", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            PyObject * sipRes = 0;

#line 435 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
        sipRes = qpycore_qobject_getattr(sipCpp, sipSelf, a0);
#line 665 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName___getattr__, doc_QObject___getattr__);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_event, "QObject.event(QEvent) -> bool");

extern "C" {static PyObject *meth_QObject_event(PyObject *, PyObject *);}
static PyObject *meth_QObject_event(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        QEvent* a0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QEvent, &a0))
        {
            bool sipRes;

            sipRes = (sipSelfWasArg ? sipCpp->QObject::event(a0) : sipCpp->event(a0));

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_event, doc_QObject_event);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_eventFilter, "QObject.eventFilter(QObject, QEvent) -> bool");

extern "C" {static PyObject *meth_QObject_eventFilter(PyObject *, PyObject *);}
static PyObject *meth_QObject_eventFilter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        QObject* a0;
        QEvent* a1;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J8", &sipSelf, sipType_QObject, &sipCpp, sipType_QObject, &a0, sipType_QEvent, &a1))
        {
            bool sipRes;

            sipRes = (sipSelfWasArg ? sipCpp->QObject::eventFilter(a0,a1) : sipCpp->eventFilter(a0,a1));

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_eventFilter, doc_QObject_eventFilter);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_tr, "QObject.tr(str, str disambiguation=None, int n=-1) -> str");

extern "C" {static PyObject *meth_QObject_tr(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_tr(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const char* a0;
        PyObject *a0Keep;
        const char* a1 = 0;
        int a2 = -1;
        const QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_disambiguation,
            sipName_n,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BA8|si", &sipSelf, sipType_QObject, &sipCpp, &a0Keep, &a0, &a1, &a2))
        {
            QString*sipRes = 0;

#line 442 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
        // Note that tr() is really a static method.  We pretend it isn't so we can use
        // self to get hold of the class name.
        
        sipRes = new QString(QCoreApplication::translate(Py_TYPE(sipSelf)->tp_name, a0, a1, a2));
#line 766 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
            Py_DECREF(a0Keep);

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_tr, doc_QObject_tr);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_findChild, "QObject.findChild(type, str name='', Qt.FindChildOptions options=Qt.FindChildrenRecursively) -> QObject\n"
    "QObject.findChild(tuple, str name='', Qt.FindChildOptions options=Qt.FindChildrenRecursively) -> QObject");

extern "C" {static PyObject *meth_QObject_findChild(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_findChild(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        const QString& a1def = QString();
        const QString* a1 = &a1def;
        int a1State = 0;
        Qt::FindChildOptions a2def = Qt::FindChildrenRecursively;
        Qt::FindChildOptions* a2 = &a2def;
        int a2State = 0;
        const QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_name,
            sipName_options,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BT|J1J1", &sipSelf, sipType_QObject, &sipCpp, &PyType_Type, &a0, sipType_QString,&a1, &a1State, sipType_Qt_FindChildOptions, &a2, &a2State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 450 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChild(sipCpp, qtcore_type_to_tuple(a0), *a1, *a2);
        
        if (!sipRes)
            sipIsErr = 1;
#line 814 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(const_cast<QString *>(a1),sipType_QString,a1State);
            sipReleaseType(a2,sipType_Qt_FindChildOptions,a2State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const QString& a1def = QString();
        const QString* a1 = &a1def;
        int a1State = 0;
        Qt::FindChildOptions a2def = Qt::FindChildrenRecursively;
        Qt::FindChildOptions* a2 = &a2def;
        int a2State = 0;
        const QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_name,
            sipName_options,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BT|J1J1", &sipSelf, sipType_QObject, &sipCpp, &PyTuple_Type, &a0, sipType_QString,&a1, &a1State, sipType_Qt_FindChildOptions, &a2, &a2State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 458 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChild(sipCpp, qtcore_check_tuple_types(a0), *a1, *a2);
        
        if (!sipRes)
            sipIsErr = 1;
#line 851 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(const_cast<QString *>(a1),sipType_QString,a1State);
            sipReleaseType(a2,sipType_Qt_FindChildOptions,a2State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_findChild, doc_QObject_findChild);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_findChildren, "QObject.findChildren(type, str name='', Qt.FindChildOptions options=Qt.FindChildrenRecursively) -> list-of-QObject\n"
    "QObject.findChildren(tuple, str name='', Qt.FindChildOptions options=Qt.FindChildrenRecursively) -> list-of-QObject\n"
    "QObject.findChildren(type, QRegExp, Qt.FindChildOptions options=Qt.FindChildrenRecursively) -> list-of-QObject\n"
    "QObject.findChildren(tuple, QRegExp, Qt.FindChildOptions options=Qt.FindChildrenRecursively) -> list-of-QObject\n"
    "QObject.findChildren(type, QRegularExpression, Qt.FindChildOptions options=Qt.FindChildrenRecursively) -> list-of-QObject\n"
    "QObject.findChildren(tuple, QRegularExpression, Qt.FindChildOptions options=Qt.FindChildrenRecursively) -> list-of-QObject");

extern "C" {static PyObject *meth_QObject_findChildren(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_findChildren(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        const QString& a1def = QString();
        const QString* a1 = &a1def;
        int a1State = 0;
        Qt::FindChildOptions a2def = Qt::FindChildrenRecursively;
        Qt::FindChildOptions* a2 = &a2def;
        int a2State = 0;
        const QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_name,
            sipName_options,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BT|J1J1", &sipSelf, sipType_QObject, &sipCpp, &PyType_Type, &a0, sipType_QString,&a1, &a1State, sipType_Qt_FindChildOptions, &a2, &a2State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 466 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_type_to_tuple(a0), *a1, *a2);
        
        if (!sipRes)
            sipIsErr = 1;
#line 907 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(const_cast<QString *>(a1),sipType_QString,a1State);
            sipReleaseType(a2,sipType_Qt_FindChildOptions,a2State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const QString& a1def = QString();
        const QString* a1 = &a1def;
        int a1State = 0;
        Qt::FindChildOptions a2def = Qt::FindChildrenRecursively;
        Qt::FindChildOptions* a2 = &a2def;
        int a2State = 0;
        const QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_name,
            sipName_options,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BT|J1J1", &sipSelf, sipType_QObject, &sipCpp, &PyTuple_Type, &a0, sipType_QString,&a1, &a1State, sipType_Qt_FindChildOptions, &a2, &a2State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 474 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_check_tuple_types(a0), *a1, *a2);
        
        if (!sipRes)
            sipIsErr = 1;
#line 944 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(const_cast<QString *>(a1),sipType_QString,a1State);
            sipReleaseType(a2,sipType_Qt_FindChildOptions,a2State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const QRegExp* a1;
        Qt::FindChildOptions a2def = Qt::FindChildrenRecursively;
        Qt::FindChildOptions* a2 = &a2def;
        int a2State = 0;
        const QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            NULL,
            sipName_options,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BTJ9|J1", &sipSelf, sipType_QObject, &sipCpp, &PyType_Type, &a0, sipType_QRegExp, &a1, sipType_Qt_FindChildOptions, &a2, &a2State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 482 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_type_to_tuple(a0), *a1, *a2);
        
        if (!sipRes)
            sipIsErr = 1;
#line 979 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(a2,sipType_Qt_FindChildOptions,a2State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const QRegExp* a1;
        Qt::FindChildOptions a2def = Qt::FindChildrenRecursively;
        Qt::FindChildOptions* a2 = &a2def;
        int a2State = 0;
        const QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            NULL,
            sipName_options,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BTJ9|J1", &sipSelf, sipType_QObject, &sipCpp, &PyTuple_Type, &a0, sipType_QRegExp, &a1, sipType_Qt_FindChildOptions, &a2, &a2State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 490 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_check_tuple_types(a0), *a1, *a2);
        
        if (!sipRes)
            sipIsErr = 1;
#line 1013 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(a2,sipType_Qt_FindChildOptions,a2State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const QRegularExpression* a1;
        Qt::FindChildOptions a2def = Qt::FindChildrenRecursively;
        Qt::FindChildOptions* a2 = &a2def;
        int a2State = 0;
        const QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            NULL,
            sipName_options,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BTJ9|J1", &sipSelf, sipType_QObject, &sipCpp, &PyType_Type, &a0, sipType_QRegularExpression, &a1, sipType_Qt_FindChildOptions, &a2, &a2State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 498 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_type_to_tuple(a0), *a1, *a2);
        
        if (!sipRes)
            sipIsErr = 1;
#line 1047 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(a2,sipType_Qt_FindChildOptions,a2State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const QRegularExpression* a1;
        Qt::FindChildOptions a2def = Qt::FindChildrenRecursively;
        Qt::FindChildOptions* a2 = &a2def;
        int a2State = 0;
        const QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            NULL,
            sipName_options,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BTJ9|J1", &sipSelf, sipType_QObject, &sipCpp, &PyTuple_Type, &a0, sipType_QRegularExpression, &a1, sipType_Qt_FindChildOptions, &a2, &a2State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 506 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_check_tuple_types(a0), *a1, *a2);
        
        if (!sipRes)
            sipIsErr = 1;
#line 1081 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(a2,sipType_Qt_FindChildOptions,a2State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_findChildren, doc_QObject_findChildren);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_objectName, "QObject.objectName() -> str");

extern "C" {static PyObject *meth_QObject_objectName(PyObject *, PyObject *);}
static PyObject *meth_QObject_objectName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            QString*sipRes;

            sipRes = new QString(sipCpp->objectName());

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_objectName, doc_QObject_objectName);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_setObjectName, "QObject.setObjectName(str)");

extern "C" {static PyObject *meth_QObject_setObjectName(PyObject *, PyObject *);}
static PyObject *meth_QObject_setObjectName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QString* a0;
        int a0State = 0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QObject, &sipCpp, sipType_QString,&a0, &a0State))
        {
            sipCpp->setObjectName(*a0);
            sipReleaseType(const_cast<QString *>(a0),sipType_QString,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_setObjectName, doc_QObject_setObjectName);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_isWidgetType, "QObject.isWidgetType() -> bool");

extern "C" {static PyObject *meth_QObject_isWidgetType(PyObject *, PyObject *);}
static PyObject *meth_QObject_isWidgetType(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isWidgetType();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_isWidgetType, doc_QObject_isWidgetType);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_isWindowType, "QObject.isWindowType() -> bool");

extern "C" {static PyObject *meth_QObject_isWindowType(PyObject *, PyObject *);}
static PyObject *meth_QObject_isWindowType(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isWindowType();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_isWindowType, doc_QObject_isWindowType);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_signalsBlocked, "QObject.signalsBlocked() -> bool");

extern "C" {static PyObject *meth_QObject_signalsBlocked(PyObject *, PyObject *);}
static PyObject *meth_QObject_signalsBlocked(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->signalsBlocked();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_signalsBlocked, doc_QObject_signalsBlocked);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_blockSignals, "QObject.blockSignals(bool) -> bool");

extern "C" {static PyObject *meth_QObject_blockSignals(PyObject *, PyObject *);}
static PyObject *meth_QObject_blockSignals(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        bool a0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            bool sipRes;

            sipRes = sipCpp->blockSignals(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_blockSignals, doc_QObject_blockSignals);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_thread, "QObject.thread() -> QThread");

extern "C" {static PyObject *meth_QObject_thread(PyObject *, PyObject *);}
static PyObject *meth_QObject_thread(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            QThread*sipRes;

            sipRes = sipCpp->thread();

            return sipConvertFromType(sipRes,sipType_QThread,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_thread, doc_QObject_thread);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_moveToThread, "QObject.moveToThread(QThread)");

extern "C" {static PyObject *meth_QObject_moveToThread(PyObject *, PyObject *);}
static PyObject *meth_QObject_moveToThread(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        QThread* a0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QThread, &a0))
        {
            sipCpp->moveToThread(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_moveToThread, doc_QObject_moveToThread);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_startTimer, "QObject.startTimer(int, Qt.TimerType timerType=Qt.CoarseTimer) -> int");

extern "C" {static PyObject *meth_QObject_startTimer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_startTimer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
        Qt::TimerType a1 = Qt::CoarseTimer;
        QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_timerType,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi|E", &sipSelf, sipType_QObject, &sipCpp, &a0, sipType_Qt_TimerType, &a1))
        {
            int sipRes;

            sipRes = sipCpp->startTimer(a0,a1);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_startTimer, doc_QObject_startTimer);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_killTimer, "QObject.killTimer(int)");

extern "C" {static PyObject *meth_QObject_killTimer(PyObject *, PyObject *);}
static PyObject *meth_QObject_killTimer(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bi", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            sipCpp->killTimer(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_killTimer, doc_QObject_killTimer);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_children, "QObject.children() -> list-of-QObject");

extern "C" {static PyObject *meth_QObject_children(PyObject *, PyObject *);}
static PyObject *meth_QObject_children(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            QObjectList*sipRes;

            sipRes = new QObjectList(sipCpp->children());

            return sipConvertFromNewType(sipRes,sipType_QList_0101QObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_children, doc_QObject_children);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_setParent, "QObject.setParent(QObject)");

extern "C" {static PyObject *meth_QObject_setParent(PyObject *, PyObject *);}
static PyObject *meth_QObject_setParent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        QObject* a0;
        sipWrapper *sipOwner = 0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJH", &sipSelf, sipType_QObject, &sipCpp, sipType_QObject, &a0, &sipOwner))
        {
            sipCpp->setParent(a0);

            if (sipOwner)
                sipTransferTo(sipSelf, (PyObject *)sipOwner);
            else
                sipTransferBack(sipSelf);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_setParent, doc_QObject_setParent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_installEventFilter, "QObject.installEventFilter(QObject)");

extern "C" {static PyObject *meth_QObject_installEventFilter(PyObject *, PyObject *);}
static PyObject *meth_QObject_installEventFilter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        QObject* a0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QObject, &a0))
        {
            sipCpp->installEventFilter(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_installEventFilter, doc_QObject_installEventFilter);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_removeEventFilter, "QObject.removeEventFilter(QObject)");

extern "C" {static PyObject *meth_QObject_removeEventFilter(PyObject *, PyObject *);}
static PyObject *meth_QObject_removeEventFilter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        QObject* a0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QObject, &a0))
        {
            sipCpp->removeEventFilter(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_removeEventFilter, doc_QObject_removeEventFilter);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_dumpObjectInfo, "QObject.dumpObjectInfo()");

extern "C" {static PyObject *meth_QObject_dumpObjectInfo(PyObject *, PyObject *);}
static PyObject *meth_QObject_dumpObjectInfo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            sipCpp->dumpObjectInfo();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_dumpObjectInfo, doc_QObject_dumpObjectInfo);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_dumpObjectTree, "QObject.dumpObjectTree()");

extern "C" {static PyObject *meth_QObject_dumpObjectTree(PyObject *, PyObject *);}
static PyObject *meth_QObject_dumpObjectTree(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            sipCpp->dumpObjectTree();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_dumpObjectTree, doc_QObject_dumpObjectTree);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_dynamicPropertyNames, "QObject.dynamicPropertyNames() -> list-of-QByteArray");

extern "C" {static PyObject *meth_QObject_dynamicPropertyNames(PyObject *, PyObject *);}
static PyObject *meth_QObject_dynamicPropertyNames(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            QList<QByteArray>*sipRes;

            sipRes = new QList<QByteArray>(sipCpp->dynamicPropertyNames());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QByteArray,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_dynamicPropertyNames, doc_QObject_dynamicPropertyNames);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_setProperty, "QObject.setProperty(str, QVariant) -> bool");

extern "C" {static PyObject *meth_QObject_setProperty(PyObject *, PyObject *);}
static PyObject *meth_QObject_setProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const char* a0;
        const QVariant* a1;
        int a1State = 0;
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BsJ1", &sipSelf, sipType_QObject, &sipCpp, &a0, sipType_QVariant, &a1, &a1State))
        {
            bool sipRes;

            sipRes = sipCpp->setProperty(a0,*a1);
            sipReleaseType(const_cast<QVariant *>(a1),sipType_QVariant,a1State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_setProperty, doc_QObject_setProperty);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_property, "QObject.property(str) -> QVariant");

extern "C" {static PyObject *meth_QObject_property(PyObject *, PyObject *);}
static PyObject *meth_QObject_property(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const char* a0;
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bs", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            QVariant*sipRes;

            sipRes = new QVariant(sipCpp->property(a0));

            return sipConvertFromNewType(sipRes,sipType_QVariant,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_property, doc_QObject_property);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_parent, "QObject.parent() -> QObject");

extern "C" {static PyObject *meth_QObject_parent(PyObject *, PyObject *);}
static PyObject *meth_QObject_parent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            QObject*sipRes;

            sipRes = sipCpp->parent();

            return sipConvertFromType(sipRes,sipType_QObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_parent, doc_QObject_parent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_inherits, "QObject.inherits(str) -> bool");

extern "C" {static PyObject *meth_QObject_inherits(PyObject *, PyObject *);}
static PyObject *meth_QObject_inherits(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const char* a0;
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bs", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            bool sipRes;

            sipRes = sipCpp->inherits(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_inherits, doc_QObject_inherits);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_deleteLater, "QObject.deleteLater()");

extern "C" {static PyObject *meth_QObject_deleteLater(PyObject *, PyObject *);}
static PyObject *meth_QObject_deleteLater(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            sipCpp->deleteLater();

            sipTransferTo(sipSelf, NULL);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_deleteLater, doc_QObject_deleteLater);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_sender, "QObject.sender() -> QObject");

extern "C" {static PyObject *meth_QObject_sender(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_sender(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const sipQObject *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            QObject*sipRes = 0;

#line 546 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
        // sender() must be called without the GIL to avoid possible deadlocks between
        // the GIL and Qt's internal thread data mutex.
        
        Py_BEGIN_ALLOW_THREADS
        
        #if defined(SIP_PROTECTED_IS_PUBLIC)
        sipRes = sipCpp->sender();
        #else
        sipRes = sipCpp->sipProtect_sender();
        #endif
        
        Py_END_ALLOW_THREADS
        
        if (!sipRes)
        {
            typedef QObject *(*qtcore_qobject_sender_t)();
        
            static qtcore_qobject_sender_t qtcore_qobject_sender = 0;
        
            if (!qtcore_qobject_sender)
                qtcore_qobject_sender = (qtcore_qobject_sender_t)sipImportSymbol("qtcore_qobject_sender");
        
            if (qtcore_qobject_sender)
                sipRes = qtcore_qobject_sender();
        }
#line 1753 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"

            return sipConvertFromType(sipRes,sipType_QObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_sender, doc_QObject_sender);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_receivers, "QObject.receivers(signal) -> int");

extern "C" {static PyObject *meth_QObject_receivers(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_receivers(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        const sipQObject *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BP0", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            int sipRes = 0;
            sipErrorState sipError = sipErrorNone;

#line 575 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
        // We need to handle the signal object.  Import the helper if it hasn't already
        // been done.
        typedef sipErrorState (*pyqt5_get_signal_signature_t)(PyObject *, const QObject *, const QByteArray &);
        
        static pyqt5_get_signal_signature_t pyqt5_get_signal_signature = 0;
        
        if (!pyqt5_get_signal_signature)
            pyqt5_get_signal_signature = (pyqt5_get_signal_signature_t)sipImportSymbol("pyqt5_get_signal_signature");
        
        if (pyqt5_get_signal_signature)
        {
            QByteArray signal_signature;
            
        #if defined(SIP_PROTECTED_IS_PUBLIC)
            if ((sipError = pyqt5_get_signal_signature(a0, sipCpp, signal_signature)) == sipErrorNone)
            {
                sipRes = sipCpp->receivers(signal_signature.constData());
            }
        #else
            if ((sipError = pyqt5_get_signal_signature(a0, static_cast<const QObject *>(sipCpp), signal_signature)) == sipErrorNone)
            {
                sipRes = sipCpp->sipProtect_receivers(signal_signature.constData());
            }
        #endif
            else if (sipError == sipErrorContinue)
            {
                sipError = sipBadCallableArg(0, a0);
            }
        }
#line 1812 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"

            if (sipError == sipErrorFail)
                return 0;

            if (sipError == sipErrorNone)
            {
            return SIPLong_FromLong(sipRes);
            }

            sipAddException(sipError, &sipParseErr);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_receivers, doc_QObject_receivers);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_timerEvent, "QObject.timerEvent(QTimerEvent)");

extern "C" {static PyObject *meth_QObject_timerEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_timerEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        QTimerEvent* a0;
        sipQObject *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QTimerEvent, &a0))
        {
            sipCpp->sipProtectVirt_timerEvent(sipSelfWasArg,a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_timerEvent, doc_QObject_timerEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_childEvent, "QObject.childEvent(QChildEvent)");

extern "C" {static PyObject *meth_QObject_childEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_childEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        QChildEvent* a0;
        sipQObject *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QChildEvent, &a0))
        {
            sipCpp->sipProtectVirt_childEvent(sipSelfWasArg,a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_childEvent, doc_QObject_childEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_customEvent, "QObject.customEvent(QEvent)");

extern "C" {static PyObject *meth_QObject_customEvent(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_customEvent(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        QEvent* a0;
        sipQObject *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QEvent, &a0))
        {
            sipCpp->sipProtectVirt_customEvent(sipSelfWasArg,a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_customEvent, doc_QObject_customEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_connectNotify, "QObject.connectNotify(QMetaMethod)");

extern "C" {static PyObject *meth_QObject_connectNotify(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_connectNotify(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        const QMetaMethod* a0;
        sipQObject *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ9", &sipSelf, sipType_QObject, &sipCpp, sipType_QMetaMethod, &a0))
        {
            sipCpp->sipProtectVirt_connectNotify(sipSelfWasArg,*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_connectNotify, doc_QObject_connectNotify);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_disconnectNotify, "QObject.disconnectNotify(QMetaMethod)");

extern "C" {static PyObject *meth_QObject_disconnectNotify(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_disconnectNotify(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        const QMetaMethod* a0;
        sipQObject *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ9", &sipSelf, sipType_QObject, &sipCpp, sipType_QMetaMethod, &a0))
        {
            sipCpp->sipProtectVirt_disconnectNotify(sipSelfWasArg,*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_disconnectNotify, doc_QObject_disconnectNotify);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_senderSignalIndex, "QObject.senderSignalIndex() -> int");

extern "C" {static PyObject *meth_QObject_senderSignalIndex(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_senderSignalIndex(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const sipQObject *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->sipProtect_senderSignalIndex();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_senderSignalIndex, doc_QObject_senderSignalIndex);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_isSignalConnected, "QObject.isSignalConnected(QMetaMethod) -> bool");

extern "C" {static PyObject *meth_QObject_isSignalConnected(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_isSignalConnected(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const QMetaMethod* a0;
        const sipQObject *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "BJ9", &sipSelf, sipType_QObject, &sipCpp, sipType_QMetaMethod, &a0))
        {
            bool sipRes;

            sipRes = sipCpp->sipProtect_isSignalConnected(*a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_isSignalConnected, doc_QObject_isSignalConnected);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_disconnect, "QObject.disconnect()");

extern "C" {static PyObject *meth_QObject_disconnect(PyObject *, PyObject *);}
static PyObject *meth_QObject_disconnect(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            PyObject * sipRes = 0;

#line 617 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
        sipRes = qpycore_qobject_disconnect(sipCpp);
#line 2044 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_disconnect, doc_QObject_disconnect);

    return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_QObject(void *, const sipTypeDef *);}
static void *cast_QObject(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_QObject)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QObject(void *, int);}
static void release_QObject(void *sipCppV,int)
{
    QObject *sipCpp = reinterpret_cast<QObject *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static int traverse_QObject(void *, visitproc, void *);}
static int traverse_QObject(void *sipCppV,visitproc sipVisit,void *sipArg)
{
    QObject *sipCpp = reinterpret_cast<QObject *>(sipCppV);
    int sipRes;

#line 399 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
    // Traverse any saved slots we might be connected to.
    sipRes = qpycore_visitSlotProxies(sipCpp, sipVisit, sipArg);
#line 2090 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"

    return sipRes;
}


extern "C" {static int clear_QObject(void *);}
static int clear_QObject(void *sipCppV)
{
    QObject *sipCpp = reinterpret_cast<QObject *>(sipCppV);
    int sipRes;

#line 404 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
    // Clear any saved slots we might be connected to.
    sipRes = qpycore_clearSlotProxies(sipCpp);
#line 2105 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"

    return sipRes;
}


extern "C" {static int final_QObject(PyObject *, void *, PyObject *, PyObject **);}
static int final_QObject(PyObject *sipSelf, void *sipCppV, PyObject *sipKwds, PyObject **sipUnused)
{
    QObject *sipCpp = reinterpret_cast<QObject *>(sipCppV);

#line 307 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
    return qpycore_qobject_finalisation(sipSelf, sipCpp, sipKwds, sipUnused);
#line 2118 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"
}


extern "C" {static void dealloc_QObject(sipSimpleWrapper *);}
static void dealloc_QObject(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerived(sipSelf))
        reinterpret_cast<sipQObject *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsPyOwned(sipSelf))
    {
        release_QObject(sipGetAddress(sipSelf),sipSelf->flags);
    }
}


extern "C" {static void *init_type_QObject(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QObject(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQObject *sipCpp = 0;

    {
        QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQObject(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QObject[] = {
    {SIP_MLNAME_CAST(sipName___getattr__), meth_QObject___getattr__, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject___getattr__)},
    {SIP_MLNAME_CAST(sipName_blockSignals), meth_QObject_blockSignals, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_blockSignals)},
    {SIP_MLNAME_CAST(sipName_childEvent), (PyCFunction)meth_QObject_childEvent, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_childEvent)},
    {SIP_MLNAME_CAST(sipName_children), meth_QObject_children, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_children)},
    {SIP_MLNAME_CAST(sipName_connectNotify), (PyCFunction)meth_QObject_connectNotify, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_connectNotify)},
    {SIP_MLNAME_CAST(sipName_customEvent), (PyCFunction)meth_QObject_customEvent, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_customEvent)},
    {SIP_MLNAME_CAST(sipName_deleteLater), meth_QObject_deleteLater, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_deleteLater)},
    {SIP_MLNAME_CAST(sipName_disconnect), meth_QObject_disconnect, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_disconnect)},
    {SIP_MLNAME_CAST(sipName_disconnectNotify), (PyCFunction)meth_QObject_disconnectNotify, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_disconnectNotify)},
    {SIP_MLNAME_CAST(sipName_dumpObjectInfo), meth_QObject_dumpObjectInfo, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_dumpObjectInfo)},
    {SIP_MLNAME_CAST(sipName_dumpObjectTree), meth_QObject_dumpObjectTree, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_dumpObjectTree)},
    {SIP_MLNAME_CAST(sipName_dynamicPropertyNames), meth_QObject_dynamicPropertyNames, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_dynamicPropertyNames)},
    {SIP_MLNAME_CAST(sipName_event), meth_QObject_event, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_event)},
    {SIP_MLNAME_CAST(sipName_eventFilter), meth_QObject_eventFilter, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_eventFilter)},
    {SIP_MLNAME_CAST(sipName_findChild), (PyCFunction)meth_QObject_findChild, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_findChild)},
    {SIP_MLNAME_CAST(sipName_findChildren), (PyCFunction)meth_QObject_findChildren, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_findChildren)},
    {SIP_MLNAME_CAST(sipName_inherits), meth_QObject_inherits, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_inherits)},
    {SIP_MLNAME_CAST(sipName_installEventFilter), meth_QObject_installEventFilter, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_installEventFilter)},
    {SIP_MLNAME_CAST(sipName_isSignalConnected), (PyCFunction)meth_QObject_isSignalConnected, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_isSignalConnected)},
    {SIP_MLNAME_CAST(sipName_isWidgetType), meth_QObject_isWidgetType, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_isWidgetType)},
    {SIP_MLNAME_CAST(sipName_isWindowType), meth_QObject_isWindowType, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_isWindowType)},
    {SIP_MLNAME_CAST(sipName_killTimer), meth_QObject_killTimer, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_killTimer)},
    {SIP_MLNAME_CAST(sipName_metaObject), meth_QObject_metaObject, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_metaObject)},
    {SIP_MLNAME_CAST(sipName_moveToThread), meth_QObject_moveToThread, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_moveToThread)},
    {SIP_MLNAME_CAST(sipName_objectName), meth_QObject_objectName, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_objectName)},
    {SIP_MLNAME_CAST(sipName_parent), meth_QObject_parent, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_parent)},
    {SIP_MLNAME_CAST(sipName_property), meth_QObject_property, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_property)},
    {SIP_MLNAME_CAST(sipName_pyqtConfigure), (PyCFunction)meth_QObject_pyqtConfigure, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_pyqtConfigure)},
    {SIP_MLNAME_CAST(sipName_receivers), (PyCFunction)meth_QObject_receivers, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_receivers)},
    {SIP_MLNAME_CAST(sipName_removeEventFilter), meth_QObject_removeEventFilter, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_removeEventFilter)},
    {SIP_MLNAME_CAST(sipName_sender), (PyCFunction)meth_QObject_sender, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_sender)},
    {SIP_MLNAME_CAST(sipName_senderSignalIndex), (PyCFunction)meth_QObject_senderSignalIndex, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_senderSignalIndex)},
    {SIP_MLNAME_CAST(sipName_setObjectName), meth_QObject_setObjectName, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_setObjectName)},
    {SIP_MLNAME_CAST(sipName_setParent), meth_QObject_setParent, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_setParent)},
    {SIP_MLNAME_CAST(sipName_setProperty), meth_QObject_setProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_setProperty)},
    {SIP_MLNAME_CAST(sipName_signalsBlocked), meth_QObject_signalsBlocked, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_signalsBlocked)},
    {SIP_MLNAME_CAST(sipName_startTimer), (PyCFunction)meth_QObject_startTimer, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_startTimer)},
    {SIP_MLNAME_CAST(sipName_thread), meth_QObject_thread, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_thread)},
    {SIP_MLNAME_CAST(sipName_timerEvent), (PyCFunction)meth_QObject_timerEvent, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_timerEvent)},
    {SIP_MLNAME_CAST(sipName_tr), (PyCFunction)meth_QObject_tr, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_tr)}
};


extern "C" {static int emit_QObject_destroyed(void *, PyObject *);}

static int emit_QObject_destroyed(void *sipCppV, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    QObject *sipCpp = reinterpret_cast<QObject *>(sipCppV);

    {
        QObject* a0 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "|J8", sipType_QObject, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->destroyed(a0);
            Py_END_ALLOW_THREADS


            return 0;
        }
    }

    sipNoMethod(sipParseErr, sipName_QObject, sipName_destroyed, NULL);

    return -1;
}


/* Define this type's signals. */
static const pyqt5QtSignal signals_QObject[] = {
    {"objectNameChanged(QString)", "\1QObject.objectNameChanged[str]", 0, 0},
    {"destroyed(QObject*)", "\1QObject.destroyed[QObject]", 0, emit_QObject_destroyed},
    {0, 0, 0, 0}
};


extern "C" {static PyObject *varget_QObject_staticMetaObject(void *, PyObject *, PyObject *);}
static PyObject *varget_QObject_staticMetaObject(void *, PyObject *, PyObject *sipPyType)
{
    PyObject *sipPy;
#line 411 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\sip/QtCore/qobject.sip"
        sipPy = qpycore_qobject_staticmetaobject(sipPyType);
#line 2246 "C:\\Users\\marcus\\Downloads\\PyQt-gpl-5.4\\PyQt-gpl-5.4\\QtCore/sipQtCoreQObject.cpp"

    return sipPy;
}

sipVariableDef variables_QObject[] = {
    {ClassVariable, sipName_staticMetaObject, (PyMethodDef *)varget_QObject_staticMetaObject, NULL, NULL, NULL},
};

PyDoc_STRVAR(doc_QObject, "\1QObject(QObject parent=None)");


pyqt5ClassTypeDef sipTypeDef_QtCore_QObject = {
{
    {
        -1,
        0,
        0,
        SIP_TYPE_SCC|SIP_TYPE_NONLAZY|SIP_TYPE_SUPER_INIT|SIP_TYPE_CLASS,
        sipNameNr_QObject,
        {0}
    },
    {
        sipNameNr_QObject,
        {0, 0, 1},
        40, methods_QObject,
        0, 0,
        1, variables_QObject,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QObject,
    sipNameNr_PyQt5_QtCore_pyqtWrapperType,
    -1,
    0,
    0,
    init_type_QObject,
    traverse_QObject,
    clear_QObject,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QObject,
    0,
    0,
    0,
    release_QObject,
    cast_QObject,
    0,
    0,
    0,
    0,
    final_QObject,
    0
},
    &QObject::staticMetaObject,
    0,
    signals_QObject,
    0
};
